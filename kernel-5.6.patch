diff -urNp -x '*.orig' lin_tape-3.0.52.org/lin_tape_ioctl_tape.c lin_tape-3.0.52/lin_tape_ioctl_tape.c
--- lin_tape-3.0.52.org/lin_tape_ioctl_tape.c	2021-02-24 22:06:04.675258765 +0100
+++ lin_tape-3.0.52/lin_tape_ioctl_tape.c	2021-02-24 22:06:04.715258642 +0100
@@ -26,6 +26,16 @@
 #include <linux/delay.h>
 #include <linux/ktime.h>
 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+struct lin_tape_timeval {
+  __kernel_long_t      tv_sec;
+  __kernel_suseconds_t tv_usec;
+};
+#else
+#define lin_tape_timeval timeval
+#endif
+
 /*****************************************************************************
  *                                                                           *
  *              Tape Drive Ioctls                                            *
@@ -2795,7 +2805,7 @@ EXIT_LABEL:
 
 ssize_t tape_set_tod(struct tape_descriptor** drvp)
 {
-	struct timeval* tv = NULL;
+	struct lin_tape_timeval* tv = NULL;
 	struct tod_control* buffer = NULL;
 	struct tape_descriptor *drv = *drvp;
 	int now = 0, rc = STATUS_SUCCESS;
@@ -2811,20 +2821,20 @@ ssize_t tape_set_tod(struct tape_descrip
 		goto EXIT_LABEL;
 	} /* if */
 
-	tv = kmalloc(sizeof(struct timeval), GFP_KERNEL);
+	tv = kmalloc(sizeof(struct lin_tape_timeval), GFP_KERNEL);
 	if(!tv) {
 		rc = -ENOMEM;
 		goto EXIT_LABEL;
 	} /* if */
 
 	memset(buffer, '\0', sizeof(struct tod_control));
-	memset(tv, '\0', sizeof(struct timeval));
+	memset(tv, '\0', sizeof(struct lin_tape_timeval));
 
 	rc = tape_modesense_page(&drv, TODControlPageNumber, (unchar*)buffer,
 		sizeof(struct tod_control), True, True);
 	if(rc != STATUS_SUCCESS) goto EXIT_LABEL;
 
-	memset(tv, '\0', sizeof(struct timeval));
+	memset(tv, '\0', sizeof(struct lin_tape_timeval));
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
 	do_gettimeofday(tv);
 #else
@@ -8940,7 +8950,7 @@ EXIT_LABEL:
 
 int erp_tod(struct tape_descriptor* drv, union cdb* tmp_cdb, char* sense_data)
 {
-	struct timeval* tv = NULL;
+	struct lin_tape_timeval* tv = NULL;
 	struct tod_control* tod_buf = NULL;
 	int now = 0, rc = -EIO;
 
@@ -8950,7 +8960,7 @@ int erp_tod(struct tape_descriptor* drv,
 		goto EXIT_LABEL;
 	} /* if */
 
-	tv = kmalloc(sizeof(struct timeval), GFP_KERNEL);
+	tv = kmalloc(sizeof(struct lin_tape_timeval), GFP_KERNEL);
 	if(!tv) {
 		rc = -ENOMEM;
 		goto EXIT_LABEL;
@@ -8961,7 +8971,7 @@ int erp_tod(struct tape_descriptor* drv,
 	if(rc != STATUS_SUCCESS) goto EXIT_LABEL;
 
 	/* get time info to set TOD */
-	memset(tv, '\0', sizeof(struct timeval));
+	memset(tv, '\0', sizeof(struct lin_tape_timeval));
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
 	do_gettimeofday(tv);
 #else
diff -urNp -x '*.orig' lin_tape-3.0.52.org/lin_tape_scsi_config.h lin_tape-3.0.52/lin_tape_scsi_config.h
--- lin_tape-3.0.52.org/lin_tape_scsi_config.h	2021-02-24 22:06:04.671925441 +0100
+++ lin_tape-3.0.52/lin_tape_scsi_config.h	2021-02-24 22:06:04.715258642 +0100
@@ -220,6 +220,7 @@ static int tape_open_proc(struct inode *
 {
 	return single_open(file, tape_read_proc, NULL);
 }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 static struct file_operations tape_proc_ops = {
     .owner   = THIS_MODULE,
     .open    = tape_open_proc,
@@ -227,6 +228,14 @@ static struct file_operations tape_proc_
     .llseek  = seq_lseek,
     .release = single_release,
 };
+#else
+static struct proc_ops tape_proc_ops = {
+    .proc_open    = tape_open_proc,
+    .proc_read    = seq_read,
+    .proc_lseek  = seq_lseek,
+    .proc_release = single_release,
+};
+#endif
 #endif
 
 int rd_pc_initial
@@ -252,6 +261,7 @@ static int changer_open_proc(struct inod
 {
 	return single_open(file, changer_read_proc, NULL);
 }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 static struct file_operations changer_proc_ops = {
     .owner   = THIS_MODULE,
     .open    = changer_open_proc,
@@ -259,6 +269,14 @@ static struct file_operations changer_pr
     .llseek  = seq_lseek,
     .release = single_release,
 };
+#else
+static struct proc_ops changer_proc_ops = {
+    .proc_open    = changer_open_proc,
+    .proc_read    = seq_read,
+    .proc_lseek  = seq_lseek,
+    .proc_release = single_release,
+};
+#endif
 #endif
 
 static int status_read_proc
@@ -270,6 +288,7 @@ static int status_open_proc(struct inode
 {
 	return single_open(file, status_read_proc, NULL);
 }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 static struct file_operations status_proc_ops = {
     .owner   = THIS_MODULE,
     .open    = status_open_proc,
@@ -277,6 +296,14 @@ static struct file_operations status_pro
     .llseek  = seq_lseek,
     .release = single_release,
 };
+#else
+static struct proc_ops status_proc_ops = {
+    .proc_open    = status_open_proc,
+    .proc_read    = seq_read,
+    .proc_lseek  = seq_lseek,
+    .proc_release = single_release,
+};
+#endif
 #endif
 
 int rdstatus_pc_initial
